name: E2E Tests with Kind

on:
  push:
  pull_request:

jobs:
  test-e2e:
    name: Run on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - name: Clone the code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Create KinD Cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: kind
          config: kind-config.yaml

      - name: Build container image with Podman
        run: |
          # Define image name and tag
          IMAGE_NAME="localhost/coverage-http-demo:test"
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

          # Build the image using Podman
          podman build --build-arg ENABLE_COVERAGE=true -t $IMAGE_NAME -f Dockerfile.local .

      - name: Load image into KinD cluster
        run: |
          podman image save -o built-image.tar ${{ env.IMAGE_NAME }}
          kind load image-archive built-image.tar

      - name: Deploy application
        run: |
          # Apply the Kubernetes deployment manifest
          kubectl apply -f k8s-deployment.yaml

          # Wait for the deployment to be ready before running tests
          kubectl wait --for=condition=Available deployment/coverage-demo -n coverage-demo --timeout=120s
          
          # Wait for pod to be fully ready
          kubectl wait --for=condition=Ready pod -l app=coverage-demo -n coverage-demo --timeout=60s
          
          # Give the service a moment to establish port mapping
          echo "Waiting for service to be accessible..."
          for i in {1..30}; do
            if curl -f http://127.0.0.1:8000/health 2>/dev/null; then
              echo "Service is accessible!"
              break
            fi
            echo "Attempt $i: Service not ready yet, retrying..."
            sleep 2
          done
          
          # Verify service is accessible
          curl -v http://127.0.0.1:8000/health

      - name: Run unit tests with coverage
        run: |
          # Run unit tests for client and server packages
          echo "Running client unit tests..."
          go test ./client/... -coverprofile=coverage-client.out -covermode=atomic
          
          echo "Running server unit tests..."
          go test ./server/... -coverprofile=coverage-server.out -covermode=atomic
          
          # Merge client and server coverage into single unit test coverage file
          echo "mode: atomic" > coverage-unit.out
          grep -h -v "^mode:" coverage-client.out coverage-server.out >> coverage-unit.out || true
          
          echo "âœ… Unit tests complete"
        continue-on-error: true

      - name: Run E2E Go Tests
        run: |
          # Run the tests and generate coverage report
          cd test
          go test -v ./...
          cp coverage-output/e2e-tests/coverage_filtered.out ../coverage-e2e.out

      - name: Merge coverage reports for SonarCloud
        run: |
          # Combine unit (client + server) and e2e coverage for SonarCloud
          echo "ðŸ“Š Merging coverage reports for SonarCloud..."
          
          if [ -f coverage-unit.out ] && [ -f coverage-e2e.out ]; then
            echo "mode: atomic" > coverage.out
            grep -h -v "^mode:" coverage-unit.out coverage-e2e.out >> coverage.out || true
            echo "âœ… Merged unit and e2e coverage"
          elif [ -f coverage-unit.out ]; then
            cp coverage-unit.out coverage.out
            echo "âœ… Using unit coverage only"
          else
            cp coverage-e2e.out coverage.out
            echo "âœ… Using e2e coverage only"
          fi
          
          # Display coverage summary
          echo "ðŸ“ˆ Coverage summary:"
          [ -f coverage-unit.out ] && echo "  Unit tests: $(grep -v "^mode:" coverage-unit.out | wc -l) lines"
          [ -f coverage-e2e.out ] && echo "  E2E tests: $(grep -v "^mode:" coverage-e2e.out | wc -l) lines"
          echo "  Combined: $(grep -v "^mode:" coverage.out | wc -l) lines"

      - name: Upload unit test coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-unit.out
          flags: unit-tests
          fail_ci_if_error: false
        if: github.repository == 'psturc/go-coverage-http' && hashFiles('coverage-unit.out') != ''

      - name: Upload E2E coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-e2e.out
          flags: e2e-tests
          fail_ci_if_error: false
        if: github.repository == 'psturc/go-coverage-http'

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=psturc_go-coverage-http
            -Dsonar.organization=psturc
            -Dsonar.go.coverage.reportPaths=coverage.out
        # This step runs only on the main branch to avoid uploading reports from forks without a secret.
        if: github.repository == 'psturc/go-coverage-http'