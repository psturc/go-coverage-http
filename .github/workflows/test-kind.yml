name: E2E Tests with K3s

on:
  push:
  pull_request_target:

jobs:
  test-e2e:
    name: Run on Ubuntu
    runs-on: ubuntu-latest
    steps:
      - name: Clone the code
        uses: actions/checkout@v5
        with:
          # For pull_request_target: checkout the PR head commit
          # For push: checkout the commit that triggered the workflow
          ref: "${{ github.event.pull_request.head.sha || github.sha }}"

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - uses: debianmaster/actions-k3s@v1.0.5
        id: k3s
        with:
          version: 'latest'

      - name: Build container image with Podman
        run: |
          # Define image name and tag
          IMAGE_NAME="localhost/coverage-http-demo:test"
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

          # Build the image using Podman
          podman build --build-arg ENABLE_COVERAGE=true -t $IMAGE_NAME -f Dockerfile.local .

      - name: Load image into K3s cluster
        run: |
          # Save the image as a tar archive
          podman image save -o built-image.tar ${{ env.IMAGE_NAME }}
          
          # Import the image into containerd (k3s uses containerd runtime)
          # Use ctr with the k8s.io namespace which is what k3s/kubernetes uses
          sudo ctr -n k8s.io images import built-image.tar
          
          # Tag the image with the exact reference that Kubernetes expects
          # After import, the image might have a different reference, so we ensure it has the correct tag
          IMPORTED_REF=$(sudo ctr -n k8s.io images ls | grep coverage-http-demo | awk '{print $1}' | head -n 1)
          if [ -n "$IMPORTED_REF" ]; then
            echo "Found imported image: $IMPORTED_REF"
            # Tag it with the name Kubernetes expects
            sudo ctr -n k8s.io images tag "$IMPORTED_REF" "${{ env.IMAGE_NAME }}"
            echo "Tagged as: ${{ env.IMAGE_NAME }}"
          fi
          
          # Verify the image is loaded and show all imported images
          echo ""
          echo "Images in containerd k8s.io namespace:"
          sudo ctr -n k8s.io images ls
          echo ""
          echo "Verifying our specific image reference:"
          sudo ctr -n k8s.io images ls | grep "${{ env.IMAGE_NAME }}" || echo "WARNING: Image with expected reference not found!"

      - name: Deploy application
        run: |
          # Apply the Kubernetes deployment manifest
          kubectl apply -f k8s-deployment.yaml

          # Debug: Check pod status and events
          echo "Checking pod status..."
          kubectl get pods -n coverage-demo -o wide || true
          kubectl describe pods -n coverage-demo || true
          
          # Wait for the deployment to be ready before running tests
          echo "Waiting for deployment to be available..."
          if ! kubectl wait --for=condition=Available deployment/coverage-demo -n coverage-demo --timeout=120s; then
            echo "Deployment failed to become available. Debugging..."
            kubectl get pods -n coverage-demo -o wide
            kubectl describe deployment coverage-demo -n coverage-demo
            kubectl describe pods -n coverage-demo
            kubectl logs -n coverage-demo -l app=coverage-demo --tail=50 || true
            exit 1
          fi
          
          # Wait for pod to be fully ready
          kubectl wait --for=condition=Ready pod -l app=coverage-demo -n coverage-demo --timeout=60s
          
          # Give the service a moment to establish port mapping
          echo "Waiting for service to be accessible..."
          for i in {1..30}; do
            if curl -f http://127.0.0.1:8000/health 2>/dev/null; then
              echo "Service is accessible!"
              break
            fi
            echo "Attempt $i: Service not ready yet, retrying..."
            sleep 2
          done
          
          # Verify service is accessible
          curl -v http://127.0.0.1:8000/health

      - name: Run unit tests with coverage
        run: |
          # Run unit tests for client and server packages
          echo "Running client unit tests..."
          go test ./client/... -coverprofile=coverage-client.out -covermode=atomic
          
          echo "Running server unit tests..."
          go test ./server/... -coverprofile=coverage-server.out -covermode=atomic
          
          # Merge client and server coverage into single unit test coverage file
          echo "mode: atomic" > coverage-unit.out
          grep -h -v "^mode:" coverage-client.out coverage-server.out >> coverage-unit.out || true
          
          echo "âœ… Unit tests complete"
        continue-on-error: true

      - name: Run E2E Go Tests
        run: |
          # Run the tests and generate coverage report
          cd test
          go test -v ./...
          cp coverage-output/e2e-tests/coverage_filtered.out ../coverage-e2e.out

      - name: Merge coverage reports for SonarCloud
        run: |
          # Combine unit (client + server) and e2e coverage for SonarCloud
          echo "ðŸ“Š Merging coverage reports for SonarCloud..."
          
          if [ -f coverage-unit.out ] && [ -f coverage-e2e.out ]; then
            echo "mode: atomic" > coverage.out
            grep -h -v "^mode:" coverage-unit.out coverage-e2e.out >> coverage.out || true
            echo "âœ… Merged unit and e2e coverage"
          elif [ -f coverage-unit.out ]; then
            cp coverage-unit.out coverage.out
            echo "âœ… Using unit coverage only"
          else
            cp coverage-e2e.out coverage.out
            echo "âœ… Using e2e coverage only"
          fi
          
          # Display coverage summary
          echo "ðŸ“ˆ Coverage summary:"
          [ -f coverage-unit.out ] && echo "  Unit tests: $(grep -v "^mode:" coverage-unit.out | wc -l) lines"
          [ -f coverage-e2e.out ] && echo "  E2E tests: $(grep -v "^mode:" coverage-e2e.out | wc -l) lines"
          echo "  Combined: $(grep -v "^mode:" coverage.out | wc -l) lines"

      - name: Upload unit test coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-unit.out
          flags: unit-tests
          fail_ci_if_error: false
        if: github.repository == 'psturc/go-coverage-http' && hashFiles('coverage-unit.out') != ''

      - name: Upload E2E coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-e2e.out
          flags: e2e-tests
          fail_ci_if_error: false

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v6.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.scm.revision=${{ github.event.pull_request.head.sha || github.sha }}
            ${{ github.event.pull_request.number && format('-Dsonar.pullrequest.key={0}', github.event.pull_request.number) || '' }}
            ${{ github.event.pull_request.number && format('-Dsonar.pullrequest.branch={0}', github.event.pull_request.head.ref) || '' }}
            ${{ github.event.pull_request.number && format('-Dsonar.pullrequest.base={0}', github.event.pull_request.base.ref) || '' }}
