apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: go-coverage-http-e2e
spec:
  description: |
    Integration test pipeline for go-coverage-http that:
    - Deploys the instrumented Go application to OpenShift
    - Runs E2E tests with coverage collection
    - Pushes coverage artifacts to quay.io as OCI artifacts
  params:
    - description: Snapshot of the application
      name: SNAPSHOT
      type: string
  tasks:
    - name: test-metadata
      params:
        - name: SNAPSHOT
          value: $(params.SNAPSHOT)
        - name: test-name
          value: $(context.pipelineRun.name)
      taskRef:
        resolver: git
        params:
          - name: url
            value: https://github.com/konflux-ci/tekton-integration-catalog.git
          - name: revision
            value: main
          - name: pathInRepo
            value: tasks/test-metadata/0.1/test-metadata.yaml
    
    - name: deploy
      runAfter:
        - test-metadata
      taskSpec:
        results:
          - name: NAMESPACE
            description: The namespace where the app was deployed
          - name: APP_URL
            description: The base URL of the deployed service
        steps:
          - name: deploy-application
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            workingDir: /workspace
            env:
              - name: JOB_SPEC
                value: $(tasks.test-metadata.results.job-spec)
              - name: SNAPSHOT
                value: $(params.SNAPSHOT)
              - name: OC_LOGIN_COMMAND
                valueFrom:
                  secretKeyRef:
                    name: integration-pipeline-credentials
                    key: oc-login-command
            script: |
              #!/bin/sh
              set -eux
              
              yum install git jq -y

              # Extract component image from SNAPSHOT
              COMPONENT_IMAGE=$(echo $SNAPSHOT | jq -r '.components[0].containerImage')
              echo "Component image: $COMPONENT_IMAGE"

              # Clone the repository
              BRANCH_NAME="$(tasks.test-metadata.results.target-repo-branch)"
              if [[ "$(tasks.test-metadata.results.test-event-type)" == "pull_request" ]]; then
                BRANCH_NAME="$(tasks.test-metadata.results.source-repo-branch)"
              fi
              git clone "$(tasks.test-metadata.results.git-url)" -b $BRANCH_NAME .

              # Login to OpenShift
              eval $OC_LOGIN_COMMAND

              # Create unique namespace for this test run
              NS="go-coverage-http-$(date +%s)"
              oc new-project $NS
              echo "Created namespace: $NS"

              # Update the deployment manifest with the component image and namespace
              sed "s|image: localhost/coverage-http-demo:test|image: $COMPONENT_IMAGE|g" k8s-deployment.yaml > k8s-deployment-updated.yaml
              sed -i "s|namespace: coverage-demo|namespace: $NS|g" k8s-deployment-updated.yaml
              
              # Convert NodePort Service to ClusterIP for OpenShift
              sed -i 's|type: NodePort|type: ClusterIP|g' k8s-deployment-updated.yaml
              sed -i '/nodePort: 30082/d' k8s-deployment-updated.yaml
              
              # Add OpenShift Route for external access
              cat >> k8s-deployment-updated.yaml << EOF
              ---
              apiVersion: route.openshift.io/v1
              kind: Route
              metadata:
                name: coverage-demo
                namespace: $NS
              spec:
                to:
                  kind: Service
                  name: coverage-demo
                port:
                  targetPort: http
                tls:
                  termination: edge
                  insecureEdgeTerminationPolicy: Redirect
              EOF
              
              echo "Updated deployment manifest:"
              cat k8s-deployment-updated.yaml
              
              # Apply the deployment
              oc apply -f k8s-deployment-updated.yaml

              # Wait for deployment to be ready
              oc wait --for=condition=Available deployment/coverage-demo -n $NS --timeout=5m
              oc wait --for=condition=ready pod -l app=coverage-demo -n $NS --timeout=5m

              # Get the route hostname
              ROUTE_HOST=$(oc get route coverage-demo -n $NS -o jsonpath='{.spec.host}')
              APP_URL="https://${ROUTE_HOST}"
              echo "Application URL: $APP_URL"

              # Verify the route is accessible
              echo "Waiting for route to be accessible..."
              for i in {1..30}; do
                if curl -k -f ${APP_URL}/health 2>/dev/null; then
                  echo "‚úÖ Route is accessible!"
                  break
                fi
                echo "Attempt $i: Route not ready yet, retrying..."
                sleep 2
              done

              echo -n "$NS" > /tekton/results/NAMESPACE
              echo -n "$APP_URL" > /tekton/results/APP_URL

    - name: run-e2e-tests
      runAfter:
        - deploy
      taskSpec:
        results:
          - name: COVERAGE_ARTIFACT_REF
            description: Full OCI reference to the coverage artifact
        volumes:
          - name: source
            emptyDir: {}
        steps:
          - name: clone-repository
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            workingDir: /workspace/source
            volumeMounts:
              - name: source
                mountPath: /workspace/source
            env:
              - name: GIT_URL
                value: $(tasks.test-metadata.results.git-url)
              - name: GIT_BRANCH
                value: $(tasks.test-metadata.results.target-repo-branch)
              - name: SOURCE_BRANCH
                value: $(tasks.test-metadata.results.source-repo-branch)
              - name: EVENT_TYPE
                value: $(tasks.test-metadata.results.test-event-type)
            script: |
              #!/bin/sh
              set -eux
              
              # Determine which branch to use
              if [ "$EVENT_TYPE" = "pull_request" ]; then
                BRANCH="$SOURCE_BRANCH"
              else
                BRANCH="$GIT_BRANCH"
              fi
              
              echo "Cloning $GIT_URL branch $BRANCH"
              git clone "$GIT_URL" -b "$BRANCH" /workspace/source
              cd /workspace/source
              echo "Repository cloned successfully"
              ls -la
          
          - name: run-tests
            image: registry.access.redhat.com/ubi9/go-toolset:1.24
            workingDir: /workspace/source
            volumeMounts:
              - name: source
                mountPath: /workspace/source
            env:
              - name: APP_NAMESPACE
                value: $(tasks.deploy.results.NAMESPACE)
              - name: APP_URL
                value: $(tasks.deploy.results.APP_URL)
              - name: COVERAGE_OUTPUT_DIR
                value: /tmp/coverage-output
              - name: PUSH_COVERAGE_ARTIFACT
                value: "true"
              - name: COVERAGE_ARTIFACT_REF_FILE
                value: /tmp/coverage-artifact-ref.txt
              - name: OC_LOGIN_COMMAND
                valueFrom:
                  secretKeyRef:
                    name: integration-pipeline-credentials
                    key: oc-login-command
              - name: QUAY_AUTH_SECRET
                valueFrom:
                  secretKeyRef:
                    name: integration-pipeline-credentials
                    key: quay-auth-secret
            script: |
              #!/bin/bash
              set -eux
              
              # Download and install oc binary
              echo "üì• Downloading oc binary..."
              curl -sL https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/oc/latest/linux/oc.tar.gz -o /tmp/oc.tar.gz
              tar -xzf /tmp/oc.tar.gz -C /tmp
              chmod +x /tmp/oc
              export PATH=/tmp:$PATH
              
              # Verify oc is available
              oc version --client
              
              # Login to OpenShift (needed for kubectl access)
              eval $OC_LOGIN_COMMAND

              # Setup Docker config for quay.io authentication
              mkdir -p ~/.docker
              echo "$QUAY_AUTH_SECRET" > ~/.docker/config.json
              echo "‚úÖ Docker authentication configured for quay.io"

              # Download Go dependencies
              go mod download

              # Create coverage output directory (already set via environment variable)
              # The go-toolset image runs as non-root and can't write to /workspace/source
              mkdir -p "$COVERAGE_OUTPUT_DIR"
              chmod 777 "$COVERAGE_OUTPUT_DIR"
              echo "‚úÖ Coverage output directory: $COVERAGE_OUTPUT_DIR"
              
              # Run E2E tests
              # The tests will:
              # 1. Discover the pod using label selector
              # 2. Port-forward to collect coverage
              # 3. Run the E2E tests
              # 4. Push coverage artifacts to quay.io
              cd test
              
              echo "üìä Running E2E tests with coverage collection..."
              echo "   Namespace: $APP_NAMESPACE"
              echo "   App URL: $APP_URL"
              echo "   Coverage Dir: $COVERAGE_OUTPUT_DIR"
              
              # Run the tests
              # Note: The test already knows to push to quay.io/psturc/coverage-artifacts
              go test -v ./...
              
              echo "‚úÖ E2E tests completed successfully!"
              
              # List the coverage files that were generated
              if [ -d "$COVERAGE_OUTPUT_DIR/e2e-tests" ]; then
                echo "üìÅ Generated coverage files:"
                ls -lh "$COVERAGE_OUTPUT_DIR/e2e-tests/"
              fi
              
              # Save the coverage artifact reference to Tekton result
              if [ -f "$COVERAGE_ARTIFACT_REF_FILE" ]; then
                ARTIFACT_REF=$(cat "$COVERAGE_ARTIFACT_REF_FILE")
                echo "üì¶ Coverage artifact reference: $ARTIFACT_REF"
                echo -n "$ARTIFACT_REF" > /tekton/results/COVERAGE_ARTIFACT_REF
              else
                echo "‚ö†Ô∏è  Coverage artifact reference file not found"
                echo "   This is expected if OCI push was skipped or failed"
                echo -n "not-available" > /tekton/results/COVERAGE_ARTIFACT_REF
              fi

    - name: process-coverage
      runAfter:
        - run-e2e-tests
      taskSpec:
        volumes:
          - name: workspace
            emptyDir: {}
        steps:
          # Step 1: Extract coverage artifact and metadata
          - name: extract-coverage-artifact
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            volumeMounts:
              - name: workspace
                mountPath: /workspace
            env:
              - name: COVERAGE_ARTIFACT_REF
                value: $(tasks.run-e2e-tests.results.COVERAGE_ARTIFACT_REF)
            script: |
              #!/bin/bash
              set -e
              
              if [ "$COVERAGE_ARTIFACT_REF" = "not-available" ]; then
                echo "‚ö†Ô∏è  No coverage artifact available, skipping processing"
                exit 0
              fi
              
              echo "=== Pulling coverage artifact with ORAS ==="
              echo "Coverage artifact: $COVERAGE_ARTIFACT_REF"
              
              mkdir -p /workspace/coverage-raw
              cd /workspace/coverage-raw
              oras pull "$COVERAGE_ARTIFACT_REF"
              
              echo "=== Coverage artifact contents ==="
              ls -la /workspace/coverage-raw/
              
              if [ ! -f /workspace/coverage-raw/metadata.json ]; then
                echo "Error: metadata.json not found"
                exit 1
              fi
              
              echo "=== metadata.json ==="
              cat /workspace/coverage-raw/metadata.json
              
              # Extract app image and save for next steps
              APP_IMAGE=$(cat /workspace/coverage-raw/metadata.json | jq -r '.container.image')
              echo "App image: $APP_IMAGE"
              echo -n "$APP_IMAGE" > /workspace/app-image
          
          # Step 2: Extract git metadata from app image attestation
          - name: extract-git-metadata
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            volumeMounts:
              - name: workspace
                mountPath: /workspace
            env:
              - name: COVERAGE_ARTIFACT_REF
                value: $(tasks.run-e2e-tests.results.COVERAGE_ARTIFACT_REF)
            script: |
              #!/bin/bash
              set -e
              
              if [ "$COVERAGE_ARTIFACT_REF" = "not-available" ]; then
                echo "‚ö†Ô∏è  Skipping (no coverage artifact)"
                exit 0
              fi
              
              APP_IMAGE=$(cat /workspace/app-image)
              echo "=== Extracting Git metadata from: $APP_IMAGE ==="
              
              # Download attestation
              cosign download attestation "$APP_IMAGE" > /workspace/attestation.json
              
              # Extract Konflux annotations
              ANNOTATIONS=$(cat /workspace/attestation.json | \
                jq -r '.payload | @base64d | fromjson | .predicate.buildConfig.tasks[0].invocation.environment.annotations')
              
              echo "=== Konflux annotations ==="
              echo "$ANNOTATIONS" | jq .
              
              # Extract repo URL and commit SHA
              REPO_URL=$(echo "$ANNOTATIONS" | jq -r '."pipelinesascode.tekton.dev/repo-url"')
              COMMIT_SHA=$(echo "$ANNOTATIONS" | jq -r '."build.appstudio.redhat.com/commit_sha"')
              
              echo "Repo URL: $REPO_URL"
              echo "Commit SHA: $COMMIT_SHA"
              
              if [ -z "$REPO_URL" ] || [ "$REPO_URL" = "null" ]; then
                echo "Error: Could not extract repo URL"
                exit 1
              fi
              
              if [ -z "$COMMIT_SHA" ] || [ "$COMMIT_SHA" = "null" ]; then
                echo "Error: Could not extract commit SHA"
                exit 1
              fi
              
              # Save for next steps
              echo -n "$REPO_URL" > /workspace/repo-url
              echo -n "$COMMIT_SHA" > /workspace/commit-sha
          
          # Step 3: Clone repository
          - name: clone-repository
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            volumeMounts:
              - name: workspace
                mountPath: /workspace
            env:
              - name: COVERAGE_ARTIFACT_REF
                value: $(tasks.run-e2e-tests.results.COVERAGE_ARTIFACT_REF)
            script: |
              #!/bin/bash
              set -e
              
              if [ "$COVERAGE_ARTIFACT_REF" = "not-available" ]; then
                echo "‚ö†Ô∏è  Skipping (no coverage artifact)"
                exit 0
              fi
              
              REPO_URL=$(cat /workspace/repo-url)
              COMMIT_SHA=$(cat /workspace/commit-sha)
              
              echo "=== Cloning repository ==="
              echo "Repository: $REPO_URL"
              echo "Commit: $COMMIT_SHA"
              
              cd /workspace
              git clone "$REPO_URL" repo
              cd repo
              git checkout "$COMMIT_SHA"
              
              echo "=== Repository cloned ==="
              ls -la
              
              if [ -f "go.mod" ]; then
                echo "Go module: $(head -1 go.mod)"
              fi
          
          # Step 4: Process and convert coverage
          - name: process-coverage
            image: golang:1.21
            volumeMounts:
              - name: workspace
                mountPath: /workspace
            env:
              - name: COVERAGE_ARTIFACT_REF
                value: $(tasks.run-e2e-tests.results.COVERAGE_ARTIFACT_REF)
            script: |
              #!/bin/bash
              set -e
              
              if [ "$COVERAGE_ARTIFACT_REF" = "not-available" ]; then
                echo "‚ö†Ô∏è  Skipping (no coverage artifact)"
                exit 0
              fi
              
              echo "=== Processing Go coverage data ==="
              
              cd /workspace/repo
              
              # Set GOCOVERDIR to the raw coverage location
              export GOCOVERDIR=/workspace/coverage-raw
              
              echo "Coverage directory: $GOCOVERDIR"
              ls -la $GOCOVERDIR/
              
              # Convert binary coverage to text format
              echo "Converting coverage to text format..."
              go tool covdata textfmt -i=$GOCOVERDIR -o=/workspace/coverage.out
              
              if [ ! -f /workspace/coverage.out ]; then
                echo "Error: Failed to generate coverage.out"
                exit 1
              fi
              
              echo "=== Coverage file generated ==="
              ls -lh /workspace/coverage.out
              
              # Show coverage percentage
              COVERAGE_PCT=$(go tool cover -func=/workspace/coverage.out | grep total: | awk '{print $3}')
              echo "Total coverage: $COVERAGE_PCT"
          
          # Step 5: Upload to Codecov
          - name: upload-to-codecov
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            volumeMounts:
              - name: workspace
                mountPath: /workspace
            env:
              - name: COVERAGE_ARTIFACT_REF
                value: $(tasks.run-e2e-tests.results.COVERAGE_ARTIFACT_REF)
              - name: CODECOV_TOKEN
                valueFrom:
                  secretKeyRef:
                    name: integration-pipeline-credentials
                    key: codecov-token
                    optional: true
            script: |
              #!/bin/bash
              set -e
              
              if [ "$COVERAGE_ARTIFACT_REF" = "not-available" ]; then
                echo "‚ö†Ô∏è  Skipping (no coverage artifact)"
                exit 0
              fi
              
              if [ -z "$CODECOV_TOKEN" ]; then
                echo "‚ö†Ô∏è  CODECOV_TOKEN not set, skipping upload"
                echo "   Add codecov-token to integration-pipeline-credentials secret to enable"
                exit 0
              fi
              
              echo "=== Uploading to Codecov ==="
              
              cd /workspace/repo
              COMMIT_SHA=$(cat /workspace/commit-sha)
              
              echo "Commit SHA: $COMMIT_SHA"
              
              # Download Codecov uploader
              curl -Os https://cli.codecov.io/latest/linux/codecov
              chmod +x codecov
              
              # Copy coverage file to repo directory
              cp /workspace/coverage.out ./coverage.out
              
              echo "=== Running Codecov uploader ==="
              ./codecov upload-coverage -t "$CODECOV_TOKEN" -f coverage.out --sha "$COMMIT_SHA" --disable-search --flag e2e-tests
              
              echo "=== Coverage uploaded successfully ==="

    - name: cleanup
      runAfter:
        - process-coverage
      taskSpec:
        steps:
          - name: cleanup-namespace
            image: quay.io/konflux-ci/tekton-integration-catalog/utils:latest
            env:
              - name: APP_NAMESPACE
                value: $(tasks.deploy.results.NAMESPACE)
              - name: OC_LOGIN_COMMAND
                valueFrom:
                  secretKeyRef:
                    name: integration-pipeline-credentials
                    key: oc-login-command
            script: |
              #!/bin/sh
              set -eux
              
              # Login to OpenShift
              eval $OC_LOGIN_COMMAND
              
              # Delete the namespace
              echo "üóëÔ∏è  Cleaning up namespace: $APP_NAMESPACE"
              oc delete namespace $APP_NAMESPACE --wait=false || true
              
              echo "‚úÖ Cleanup initiated"

